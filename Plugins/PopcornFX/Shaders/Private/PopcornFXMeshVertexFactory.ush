//----------------------------------------------------------------------------
// This program is the property of Persistant Studios SARL.
//
// You may not redistribute it and/or modify it under any conditions
// without written permission from Persistant Studios SARL, unless
// otherwise stated in the latest Persistant Studios Code License.
//
// See the Persistant Studios Code License for further details.
//----------------------------------------------------------------------------

/*=============================================================================
	MeshParticleVertexFactory.usf: Mesh particle vertex factory shader code.
=============================================================================*/

#if (ENGINE_MINOR_VERSION >= 17)
#	include "/Engine/Private/VertexFactoryCommon.ush"
#else
#	include "VertexFactoryCommon.usf"
#endif

#if ENGINE_MINOR_VERSION <= 15
#	define NUM_TEX_COORD_INTERPOLATORS		NUM_MATERIAL_TEXCOORDS
#endif

// These are only enabled for SM5 due to limited interpolators elsewhere
#define USE_PARTICLE_NODES (FEATURE_LEVEL >= FEATURE_LEVEL_SM5)
#if ENGINE_MINOR_VERSION >= 16
#	define USE_PARTICLE_POSITION (FEATURE_LEVEL >= FEATURE_LEVEL_SM5 && (NEEDS_PARTICLE_POSITION || PASS_NEEDS_PRIMITIVE_VOLUME_BOUNDS))
#else
#	define USE_PARTICLE_POSITION (USE_PARTICLE_NODES && 1)
#endif
#define USE_PARTICLE_TIME (FEATURE_LEVEL >= FEATURE_LEVEL_SM5 && NEEDS_PARTICLE_TIME)

// Only support previous transform for deferred feature level
#define USE_PREVIOUS_TRANSFORM (FEATURE_LEVEL >= FEATURE_LEVEL_SM4)

#if !PARTICLE_MESH_INSTANCED
float4 Transform1;
float4 Transform2;
float4 Transform3;
float4 Transform4;
float4 ParticleColor;
#endif

struct FVertexFactoryInput
{
	float4	Position : ATTRIBUTE0;
	half3	TangentX : ATTRIBUTE1;
	// TangentZ.w contains sign of tangent basis determinant
	half4	TangentZ : ATTRIBUTE2;
	half4	VertexColor : ATTRIBUTE3;

#if NUM_MATERIAL_TEXCOORDS_VERTEX
	float2	TexCoords[NUM_MATERIAL_TEXCOORDS_VERTEX] : ATTRIBUTE4;
#endif

#if PARTICLE_MESH_INSTANCED
	float4 Transform1 : ATTRIBUTE8;
	float4 Transform2 : ATTRIBUTE9;
	float4 Transform3 : ATTRIBUTE10;
	float4 Transform4 : ATTRIBUTE11;

	float4 ParticleColor : ATTRIBUTE13;
#endif

	/** Optional instance ID for vertex layered rendering */
#if (PARTICLE_MESH_INSTANCED || (FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && ONEPASS_POINTLIGHT_SHADOW && USING_VERTEX_SHADER_LAYER))
	uint InstanceId	: SV_InstanceID;
#endif
};

struct FVertexFactoryInterpolantsVSToPS
{
	TANGENTTOWORLD_INTERPOLATOR_BLOCK

#if NUM_TEX_COORD_INTERPOLATORS
		#if (ES2_PROFILE || ES3_1_PROFILE)
			// Avoid dependent texture fetches, put all UVs in xy
			float2	TexCoords[NUM_TEX_COORD_INTERPOLATORS] : TEXCOORD0;
		#else
			float4	TexCoords[(NUM_TEX_COORD_INTERPOLATORS+1)/2] : TEXCOORD0;
		#endif
#endif

#if INTERPOLATE_VERTEX_COLOR
	float4	VertexColor : COLOR0;
#endif

#if NEEDS_PARTICLE_COLOR
	float4	ParticleColor : COLOR1;
#endif

#if USE_PARTICLE_NODES

#if USE_PARTICLE_POSITION
	/** Particle position in camera-centered translated world space */
	float3 ParticleTranslatedWorldPosition	: PARTICLE_POSITION;
#endif

#if NEEDS_PARTICLE_TRANSFORM
	float4 LocalToWorld[4] : PARTICLE_TRANSFORM;
#endif

#endif

#if INSTANCED_STEREO
	nointerpolation uint PackedEyeIndex : PACKED_EYE_INDEX;
#endif
};

struct FVertexFactoryIntermediates
{
	/** The color of the vertex. */
	float4 VertexColor;

	/** The color of the particle. */
	float4 ParticleColor;

	/** The texture coordinates for the vertex. */
#if NUM_MATERIAL_TEXCOORDS_VERTEX
	float2	TexCoords[NUM_MATERIAL_TEXCOORDS_VERTEX];
#endif

	/** Particle position in camera-centered translated world space. */
	float3 ParticleTranslatedWorldPosition;

#if NEEDS_PARTICLE_TRANSFORM
	float4 LocalToWorld[4];
#endif

};

float4x4 GetParticleTransform(FVertexFactoryInput Input)
{
#if PARTICLE_MESH_INSTANCED
	return float4x4(Input.Transform1, Input.Transform2, Input.Transform3, Input.Transform4);
#else
	return float4x4(Transform1, Transform2, Transform3, Transform4);
#endif
}

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 PixelPosition)
{
	// GetMaterialPixelParameters is responsible for fully initializing the result
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

#if NUM_TEX_COORD_INTERPOLATORS
	#if (ES2_PROFILE || ES3_1_PROFILE)
		UNROLL
		for( int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++ )
		{
			Result.TexCoords[CoordinateIndex] = Interpolants.TexCoords[CoordinateIndex].xy;
		}
	#else
		UNROLL
		for(int CoordinateIndex = 0;CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS;CoordinateIndex += 2)
		{
			Result.TexCoords[CoordinateIndex] = Interpolants.TexCoords[CoordinateIndex/2].xy;

			if(CoordinateIndex + 1 < NUM_TEX_COORD_INTERPOLATORS)
			{
				Result.TexCoords[CoordinateIndex + 1] = Interpolants.TexCoords[CoordinateIndex/2].wz;
			}
		}
	#endif
#endif

	half3 TangentToWorld0 = Interpolants.TangentToWorld0.xyz;
	half4 TangentToWorld2 = Interpolants.TangentToWorld2;
	Result.UnMirrored = TangentToWorld2.w;

#if INTERPOLATE_VERTEX_COLOR
	Result.VertexColor = Interpolants.VertexColor;
#else
	Result.VertexColor = 0;
#endif

#if NEEDS_PARTICLE_COLOR
	Result.Particle.Color = Interpolants.ParticleColor;
#endif

#if USE_PARTICLE_NODES
	#if USE_PARTICLE_POSITION
		Result.Particle.TranslatedWorldPositionAndSize.xyz = Interpolants.ParticleTranslatedWorldPosition.xyz;
		Result.Particle.TranslatedWorldPositionAndSize.w = 1;
	#endif

	#if NEEDS_PARTICLE_TRANSFORM
		Result.Particle.LocalToWorld[0] = Interpolants.LocalToWorld[0];
		Result.Particle.LocalToWorld[1] = Interpolants.LocalToWorld[1];
		Result.Particle.LocalToWorld[2] = Interpolants.LocalToWorld[2];
		Result.Particle.LocalToWorld[3] = Interpolants.LocalToWorld[3];
	#endif
#endif

	Result.Particle.MotionBlurFade = 1.0f;
	Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);
	Result.TwoSidedSign = 1;

	return Result;
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, float3x3 TangentToLocal)
{
	FMaterialVertexParameters Result = (FMaterialVertexParameters)0;
	Result.WorldPosition = WorldPosition;
	Result.VertexColor = Intermediates.VertexColor;
	Result.PreSkinnedPosition = Input.Position.xyz;
	Result.PreSkinnedNormal = Input.TangentZ.xyz * 2.f - 1.f;

#if PARTICLE_MESH_INSTANCED
	Result.Particle.Color = Input.ParticleColor;
#else
	Result.Particle.Color = ParticleColor;
#endif

	Result.Particle.TranslatedWorldPositionAndSize.xyz = Intermediates.ParticleTranslatedWorldPosition.xyz;
	Result.Particle.TranslatedWorldPositionAndSize.w = 1;

	float4x4 Transform = GetParticleTransform(Input);
	Result.InstanceLocalToWorld = Transform;
#if NEEDS_PARTICLE_TRANSFORM
	Result.Particle.LocalToWorld[0] = Transform[0];
	Result.Particle.LocalToWorld[1] = Transform[1];
	Result.Particle.LocalToWorld[2] = Transform[2];
	Result.Particle.LocalToWorld[3] = Transform[3];
#endif

	Result.TangentToWorld = mul(TangentToLocal, (float3x3)Transform);

#if NUM_MATERIAL_TEXCOORDS_VERTEX
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS_VERTEX; CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = Intermediates.TexCoords[CoordinateIndex];
	}
#endif

	return Result;
}

#if NEEDS_LIGHTMAP_COORDINATE
void GetLightMapCoordinates(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 LightmapUV0, out float2 LightmapUV1)
{
	LightmapUV0 = LightmapUV1 = 0;
}

half2 GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
#endif


float4 CalcWorldPosition(FVertexFactoryInput Input)
{
	float4x4 Transform = GetParticleTransform(Input);
	float3 WorldPosition = mul(Input.Position, Transform).xyz + ResolvedView.PreViewTranslation;
	return float4(WorldPosition, Input.Position.w);
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
	// Swizzle vertex color.
	Intermediates.VertexColor = Input.VertexColor FCOLOR_COMPONENT_SWIZZLE;

	// World position.
#if PARTICLE_MESH_INSTANCED
	float3 ParticleWorldPosition = Input.Transform4.xyz;
#if NEEDS_PARTICLE_TRANSFORM
	float4x4 LocalToWorldMat = float4x4(Input.Transform1, Input.Transform2, Input.Transform3, float4(0.0f, 0.0f, 0.0f, 1.0f));
	Intermediates.LocalToWorld[0] = LocalToWorldMat[0];
	Intermediates.LocalToWorld[1] = LocalToWorldMat[1];
	Intermediates.LocalToWorld[2] = LocalToWorldMat[2];
	Intermediates.LocalToWorld[3] = LocalToWorldMat[3];
#endif
#else
	float3 ParticleWorldPosition = Transform4.xyz;
#endif

	Intermediates.ParticleTranslatedWorldPosition = ParticleWorldPosition + ResolvedView.PreViewTranslation.xyz;

#if PARTICLE_MESH_INSTANCED
	Intermediates.ParticleColor = Input.ParticleColor;
#else
	Intermediates.ParticleColor = ParticleColor;
#endif

#if NUM_MATERIAL_TEXCOORDS_VERTEX
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS_VERTEX; CoordinateIndex++)
	{
		Intermediates.TexCoords[CoordinateIndex] = Input.TexCoords[CoordinateIndex].xy;
	}
#endif

	return Intermediates;
}

/**
* Get the 3x3 tangent basis vectors for this vertex factory
* this vertex factory will calculate the binormal on-the-fly
*
* @param Input - vertex input stream structure
* @return 3x3 matrix
*/
float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	float3x3 Result = 0;
	float4 TangentZ = TangentBias(Input.TangentZ);

	// pass-thru the tangent
	Result[0] = TangentBias(Input.TangentX);
	// pass-thru the normal
	Result[2] = TangentZ.xyz;


	// derive the binormal by getting the cross product of the normal and tangent
	Result[1] = cross(Result[2], Result[0]) * TangentZ.w;
	// Recalculate TangentX off of the other two vectors
	// This corrects quantization error since TangentX was passed in as a quantized vertex input
	// The error shows up most in specular off of a mesh with a smoothed UV seam (normal is smooth, but tangents vary across the seam)
	Result[0] = cross(Result[1], Result[2]) * TangentZ.w;

	return Result;
}

// @return translated world position
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return CalcWorldPosition(Input);
}

// since 4.12
float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
	return TranslatedWorldPosition;
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
	return InWorldPosition;
}

void CalcTangentToWorld(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, out float3 TangentToWorld0, out float4 TangentToWorld2)
{
	float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, Intermediates);

	float4x4 Transform = GetParticleTransform(Input);
	float3x3 TangentToWorld = mul(TangentToLocal, (float3x3)Transform);

	// Normalize to remove scaling. Incorrect but faster than computing the inverse-transpose.
	TangentToWorld0 = normalize(TangentToWorld[0]);
	TangentToWorld2 = normalize(float4(TangentToWorld[2], TangentBias(Input.TangentZ.w) * Primitive.LocalToWorldDeterminantSign));
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants;

#if NUM_TEX_COORD_INTERPOLATORS
	#if (ES2_PROFILE || ES3_1_PROFILE)
		GetMaterialCustomizedUVs(VertexParameters, Interpolants.TexCoords);
	#else
		// Ensure the unused components of the last packed texture coordinate are initialized.
		Interpolants.TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2 - 1] = 0;

		float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
		GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
#if ENGINE_MINOR_VERSION >= 16
		GetCustomInterpolators(VertexParameters, CustomizedUVs);
#endif

		UNROLL
		for(int CoordinateIndex = 0;CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS;CoordinateIndex += 2)
		{
			Interpolants.TexCoords[CoordinateIndex / 2].xy = CustomizedUVs[CoordinateIndex];
			if(CoordinateIndex + 1 < NUM_TEX_COORD_INTERPOLATORS)
			{
				Interpolants.TexCoords[CoordinateIndex / 2].wz = CustomizedUVs[CoordinateIndex + 1];
			}
		}
	#endif
#endif

	Interpolants.TangentToWorld0.w = 0;
	CalcTangentToWorld(Input, Intermediates, Interpolants.TangentToWorld0.xyz, Interpolants.TangentToWorld2);

#if INTERPOLATE_VERTEX_COLOR
	Interpolants.VertexColor = Intermediates.VertexColor;
#endif

#if NEEDS_PARTICLE_COLOR
	Interpolants.ParticleColor = Intermediates.ParticleColor;
#endif

//#if USE_DYNAMIC_PARAMETERS
//	Interpolants.DynamicParameter = Intermediates.DynamicParameter;
//#endif	//USE_DYNAMIC_PARAMETERS

#if USE_PARTICLE_NODES
	#if USE_PARTICLE_POSITION
		Interpolants.ParticleTranslatedWorldPosition = Intermediates.ParticleTranslatedWorldPosition;
	#endif
	#if NEEDS_PARTICLE_TRANSFORM
		Interpolants.LocalToWorld = Intermediates.LocalToWorld;
	#endif
#endif

#if INSTANCED_STEREO
	Interpolants.PackedEyeIndex = 0;
#endif

	return Interpolants;
}

// @return previous translated world position
float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	// The previous local to world instance transform isn't available.
	return CalcWorldPosition(Input);
}

#if USING_TESSELLATION
struct FVertexFactoryInterpolantsVSToDS
{
	FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
};

float2 VertexFactoryGetTextureCoordinateDS(FVertexFactoryInterpolantsVSToDS Interpolants)
{
#if NUM_MATERIAL_TEXCOORDS
	return Interpolants.InterpolantsVSToPS.TexCoords[0].xy;
#else // #if NUM_MATERIAL_TEXCOORDS
	return float2(0, 0);
#endif // #if NUM_MATERIAL_TEXCOORDS
}

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryInterpolantsVSToDS Input)
{
	return Input.InterpolantsVSToPS;
}

/** Converts from vertex factory specific interpolants to a FMaterialTessellationParameters, which is used by material inputs. */
FMaterialTessellationParameters GetMaterialTessellationParameters(FVertexFactoryInterpolantsVSToDS Interpolants, float3 CameraLocalWorldPosition)
{
	FMaterialTessellationParameters	Result;
#if NUM_TEX_COORD_INTERPOLATORS
	UNROLL
	for(int CoordinateIndex = 0;CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS;CoordinateIndex += 2)
	{
		Result.TexCoords[CoordinateIndex] = Interpolants.InterpolantsVSToPS.TexCoords[CoordinateIndex/2].xy;
		if(CoordinateIndex + 1 < NUM_TEX_COORD_INTERPOLATORS)
		{
			Result.TexCoords[CoordinateIndex + 1] = Interpolants.InterpolantsVSToPS.TexCoords[CoordinateIndex/2].wz;
		}
	}
#endif

	Result.VertexColor = float4(1, 1, 1, 1);

	half3 TangentToWorld0 = Interpolants.InterpolantsVSToPS.TangentToWorld0.xyz;
	half4 TangentToWorld2 = Interpolants.InterpolantsVSToPS.TangentToWorld2;
	Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);
	Result.TangentToWorldPreScale = 1;
	Result.WorldPosition = CameraLocalWorldPosition + ResolvedView.WorldCameraOrigin.xyz;

	return Result;
}

FVertexFactoryInterpolantsVSToDS VertexFactoryGetInterpolantsVSToDS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToDS Interpolants;
	Interpolants.InterpolantsVSToPS = VertexFactoryGetInterpolantsVSToPS(Input, Intermediates, VertexParameters);
	return Interpolants;
}

FVertexFactoryInterpolantsVSToDS VertexFactoryInterpolate(FVertexFactoryInterpolantsVSToDS a, float aInterp, FVertexFactoryInterpolantsVSToDS b, float bInterp)
{
	FVertexFactoryInterpolantsVSToDS O;

	// Do we really need to interpolate TangentToWorld2 here? It should be replaced by the
	// interpolated normal from 'whatever' interpolation scheme we're using

	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld0.xyz);
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld2);
#if INTERPOLATE_VERTEX_COLOR
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.VertexColor);
#endif

#if NEEDS_PARTICLE_COLOR
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.ParticleColor);
#endif

#if NUM_TEX_COORD_INTERPOLATORS
	for (int i = 0; i < (NUM_TEX_COORD_INTERPOLATORS + 1) / 2; ++i)
	{
		TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TexCoords[i]);
	}
#endif

	return O;
}

float3x3 VertexFactoryGetTangentToLocalDS(FVertexFactoryInterpolantsVSToDS Interpolants)
{
	// This duplicates stuff already going on in GetMaterialTessellationParameters(), so
	// maybe the hull shader could leverage that instead?
	half3 TangentToWorld0 = Interpolants.InterpolantsVSToPS.TangentToWorld0.xyz;
	half4 TangentToWorld2 = Interpolants.InterpolantsVSToPS.TangentToWorld2;
	float3x3 TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);

	return TangentToWorld;
}
#endif // #if USING_TESSELLATION

#if INSTANCED_STEREO

// Instanced stereo sets the eye index explicitly for instanced geometry
#if PARTICLE_MESH_INSTANCED
uint InstancedEyeIndex;
#endif

uint VertexFactoryGetEyeIndex(uint InstanceId)
{
	#if PARTICLE_MESH_INSTANCED
		return InstancedEyeIndex & bIsInstancedStereo;
	#else
		return InstanceId & 1;
	#endif
}
#endif

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
