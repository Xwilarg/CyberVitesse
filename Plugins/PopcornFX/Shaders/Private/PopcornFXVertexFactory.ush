//----------------------------------------------------------------------------
// This program is the property of Persistant Studios SARL.
//
// You may not redistribute it and/or modify it under any conditions
// without written permission from Persistant Studios SARL, unless
// otherwise stated in the latest Persistant Studios Code License.
//
// See the Persistant Studios Code License for further details.
//----------------------------------------------------------------------------

// 1

/*=============================================================================
	PopcornFXVertexFactory.usf: PopcornFX Vertex factory shader code.
=============================================================================*/

#if (ENGINE_MINOR_VERSION >= 17)
#	include "/Engine/Private/VertexFactoryCommon.ush"
#else
#	include "VertexFactoryCommon.usf"
#endif

// We don't compute a tangent basis in ES2 to save shader instructions.
#define NEEDS_TANGENT_BASIS			(FEATURE_LEVEL >= FEATURE_LEVEL_SM4)

// RightHanded:
//#define		myCross(a, b)		cross(a, b)
// LeftHanded:
#define		myCross(a, b)		cross(b, a)

#define		swap(x, y)		x = asfloat(asuint(x) ^ asuint(y)); y = asfloat(asuint(y) ^ asuint(x)); x = asfloat(asuint(x) ^ asuint(y));

//----------------------------------------------------------------------------
// VS uniforms
//----------------------------------------------------------------------------

int			IsSoftAnimBlended;

#define	HasTexCoord2		(IsSoftAnimBlended)

//----------------------------------------------------------------------------
// VS + FS uniforms
//----------------------------------------------------------------------------

int		NeedNorTan;

//----------------------------------------------------------------------------
// FS uniforms
//----------------------------------------------------------------------------

int		IsHighQuality;
int		IsRotated;

//----------------------------------------------------------------------------
// VS Inputs
//----------------------------------------------------------------------------

struct FVertexFactoryInput
{
	float3	Position				: ATTRIBUTE0;
	float3	Normal					: ATTRIBUTE1;
	float4	Tangent					: ATTRIBUTE2;
	float4	Color					: ATTRIBUTE3;
	float2	TexCoord				: ATTRIBUTE4;
	float2	TexCoord2				: ATTRIBUTE5;
	float4	UVFactors				: ATTRIBUTE6;
	float4	UVScalesAndOffsets		: ATTRIBUTE7;
	float	AtlasID					: ATTRIBUTE8;
	float	AlphaCursor				: ATTRIBUTE9;

	/** Optional instance ID for vertex layered rendering */
	#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && ONEPASS_POINTLIGHT_SHADOW && USING_VERTEX_SHADER_LAYER
	uint	InstanceId	: SV_InstanceID;
	#endif
};

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

struct FVertexFactoryIntermediates
{
	float3	Position;
};

//----------------------------------------------------------------------------
// VS to PS
//----------------------------------------------------------------------------

struct FVertexFactoryInterpolantsVSToPS
{
	float4	Color				: TEXCOORD0;
	float4	TexCoord			: TEXCOORD1;
	float3	Normal				: TEXCOORD2;
	float3	Tangent				: TEXCOORD3;
	float4	UVFactors			: TEXCOORD4;
	float4	UVScalesAndOffsets	: TEXCOORD5;
#if USE_DYNAMIC_PARAMETERS
	float4	DynamicParameter	: COLOR0;
#endif // USE_DYNAMIC_PARAMETERS

#if INSTANCED_STEREO
	nointerpolation uint PackedEyeIndex : PACKED_EYE_INDEX;
#endif
};

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 PixelPosition)
{
	// GetMaterialPixelParameters is responsible for fully initializing the result
	FMaterialPixelParameters	PixelParameters = MakeInitializedMaterialPixelParameters();

	// TODO : Correct deformation on SoftAnim (texcoords.zw) ?
	if (IsHighQuality)
	{
		float 	mul1 = saturate(((Interpolants.TexCoord.x + Interpolants.TexCoord.y) - 1.0f) * 1e10);
		float	oneMinus = 1.0f - mul1;
		float2	UVFactorsXY = (Interpolants.TexCoord.xy / Interpolants.UVFactors.xy) * float2(oneMinus, oneMinus);
		float2	UVFactorsZW = (float2(1.0f, 1.0f) - ((float2(1.0f, 1.0f) - Interpolants.TexCoord.xy) / Interpolants.UVFactors.zw)) * float2(mul1, mul1);
		float2	UVs = UVFactorsXY + UVFactorsZW;
		if (IsRotated)
			UVs = float2(UVs.y, UVs.x);
		Interpolants.TexCoord.xy = (UVs * Interpolants.UVScalesAndOffsets.xy) + Interpolants.UVScalesAndOffsets.zw;
	}

#if NUM_MATERIAL_TEXCOORDS
	#if NUM_MATERIAL_TEXCOORDS >= 1
		PixelParameters.TexCoords[0] = Interpolants.TexCoord.xy;
		#if NUM_MATERIAL_TEXCOORDS >= 2
			PixelParameters.TexCoords[1] = Interpolants.TexCoord.zw;
		#endif	// >= 2
	#endif	// >= 1

	#if NUM_MATERIAL_TEXCOORDS > 3
		UNROLL
		for(int CoordinateIndex = 2; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; CoordinateIndex++)
		{
			PixelParameters.TexCoords[CoordinateIndex] = Interpolants.TexCoord.xy;
		}
	#endif	// > 3
#endif	//NUM_MATERIAL_TEXCOORDS

#if USE_DYNAMIC_PARAMETERS
	PixelParameters.Particle.DynamicParameter = Interpolants.DynamicParameter;
#endif // USE_DYNAMIC_PARAMETERS
	PixelParameters.VertexColor = Interpolants.Color;
	PixelParameters.UnMirrored = 1;
	PixelParameters.TwoSidedSign = 1;

	// world normal will be overriden by TangentToWorld[2]
	//PixelParameters.WorldNormal = Interpolants.Normal;

#if NEEDS_TANGENT_BASIS
	if (NeedNorTan)
	{
		float3		normal = Interpolants.Normal;
		float3		tangent = Interpolants.Tangent;
		float3		binormal = normalize(cross(normal, tangent));
		tangent = cross(binormal, normal);

		PixelParameters.TangentToWorld[0] = tangent;
		PixelParameters.TangentToWorld[1] = binormal;
		PixelParameters.TangentToWorld[2] = normal;
	}
#endif
	return PixelParameters;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, float3x3 TangentToLocal)
{
	FMaterialVertexParameters VertexParameters = (FMaterialVertexParameters)0;

#if NUM_MATERIAL_TEXCOORDS
	#if NUM_MATERIAL_TEXCOORDS >= 1
		VertexParameters.TexCoords[0] = Input.TexCoord;
		#if NUM_MATERIAL_TEXCOORDS >= 2
			if (HasTexCoord2)
				VertexParameters.TexCoords[1] = Input.TexCoord2;
			else
				VertexParameters.TexCoords[1] = Input.TexCoord;
		#endif	// >= 2
	#endif	// >= 1

	#if NUM_MATERIAL_TEXCOORDS > 3
		UNROLL
		for(int CoordinateIndex = 2; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; CoordinateIndex++)
		{
			VertexParameters.TexCoords[CoordinateIndex] = Input.TexCoord;
		}
	#endif	// > 3
#endif	//NUM_MATERIAL_TEXCOORDS

	VertexParameters.WorldPosition = WorldPosition;
	VertexParameters.VertexColor = Input.Color;
#if ENGINE_MINOR_VERSION >= 14
	VertexParameters.PreSkinnedPosition = Input.Position.xyz;
#endif
#if ENGINE_MINOR_VERSION >= 15
	VertexParameters.PreSkinnedNormal = TangentToLocal[2].xyz;
#endif

#if USE_DYNAMIC_PARAMETERS
	VertexParameters.Particle.DynamicParameter = float4(Input.AtlasID, Input.AlphaCursor, 0, 0);
#endif

	VertexParameters.TangentToWorld = mul(TangentToLocal, GetLocalToWorld3x3());
	return VertexParameters;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

// Construct the vertex factory intermediates
FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;

	float3	vertexPosition = Input.Position;

	float3	worldVertexPosition = mul(float4(vertexPosition,1), Primitive.LocalToWorld).xyz;
#if ENGINE_MINOR_VERSION >= 11
	worldVertexPosition += ResolvedView.PreViewTranslation;
#else
	worldVertexPosition += View.PreViewTranslation;
#endif

	// @TODO rotate vertexNormal ??????
	//float3	worldVertexNormal = vertexNormal;
	//float3	worldVertexTangent = vertexTangent;

	Intermediates.Position = worldVertexPosition;
	//Intermediates.Normal = worldVertexNormal;
	//Intermediates.Tangent = worldVertexTangent;

	return Intermediates;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

// Simply construct a float4 value from the previously computed position
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float4(Intermediates.Position, 1);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

// No additional computation, simply return the already translated world position
float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 TranslatedWorldPosition)
{
	return TranslatedWorldPosition;
}

// since 4.12
float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
	return TranslatedWorldPosition;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;

	Interpolants.TexCoord.xy = Input.TexCoord;
	if (HasTexCoord2)
		Interpolants.TexCoord.zw = Input.TexCoord2;
	Interpolants.Color = Input.Color;
	Interpolants.Normal = Input.Normal;
	Interpolants.Tangent = Input.Tangent;

	Interpolants.UVFactors = Input.UVFactors;
	Interpolants.UVScalesAndOffsets = Input.UVScalesAndOffsets;

#	if USE_DYNAMIC_PARAMETERS
	//if (IsSoftAnimBlended)
	Interpolants.DynamicParameter = float4(Input.AtlasID, Input.AlphaCursor, 0, 0);
	//Interpolants.DynamicParameter = Input.DynamicParameter;
#	endif

#if INSTANCED_STEREO
	Interpolants.PackedEyeIndex = 0;
#endif

	return Interpolants;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

// we dont care, seems use only as parameter for GetMaterialVertexParameters (who dont use it)
float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

void GetLightMapCoordinates(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 LightmapUV0, out float2 LightmapUV1)
{
	LightmapUV0 = LightmapUV1 = 0;
}

half2 GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return VertexFactoryGetWorldPosition(Input, Intermediates);
}

#if INSTANCED_STEREO

// Instanced stereo sets the eye index explicitly for instanced geometry
//uint InstancedEyeIndex;	 

uint VertexFactoryGetEyeIndex(uint InstanceId)
{
	//return InstancedEyeIndex & bIsInstancedStereo;

	// We are not instanced to start with
	// Instanced Stereo will make us instanced
	// So, we need to get eye index from InstanceId instead of the InstancedEyeIndex uniform
	return InstanceId & 1;
}
#endif

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
