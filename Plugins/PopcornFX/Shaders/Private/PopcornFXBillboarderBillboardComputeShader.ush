//----------------------------------------------------------------------------
// This program is the property of Persistant Studios SARL.
//
// You may not redistribute it and/or modify it under any conditions
// without written permission from Persistant Studios SARL, unless
// otherwise stated in the latest Persistant Studios Code License.
//
// See the Persistant Studios Code License for further details.
//----------------------------------------------------------------------------

/*=============================================================================
PopcornFXBillboarderBillboardComputeShader.usf: CParticleRenderer_Billboard compute shader billboarder
=============================================================================*/

#if (ENGINE_MINOR_VERSION >= 17)
#	include "/Engine/Private/Common.ush"
#	include "/Engine/Private/Definitions.ush"
#else
#	include "Common.usf"
#	include "Definitions.usf"
#endif

//RWByteAddressBuffer		OutIndices;
RWBuffer<uint>			OutIndices;

RWByteAddressBuffer		OutPositions;
RWByteAddressBuffer		OutColors;
RWByteAddressBuffer		OutTexcoords;
RWByteAddressBuffer		OutTexcoord2s;
RWByteAddressBuffer		OutAtlasIDs;
RWByteAddressBuffer		OutNormals;
RWByteAddressBuffer		OutTangents;

ByteAddressBuffer		InIndices;
ByteAddressBuffer		InPositions;
ByteAddressBuffer		InSizes;
ByteAddressBuffer		In2Sizes;
ByteAddressBuffer		InColors;
ByteAddressBuffer		InRotations;
ByteAddressBuffer		InAxis0s;
ByteAddressBuffer		InAxis1s;
ByteAddressBuffer		InTextureIds;

float4		DefaultInPositions;
float4		DefaultInSizes;
float4		DefaultIn2Sizes;
float4		DefaultInColors;
float4		DefaultInRotations;
float4		DefaultInAxis0s;
float4		DefaultInAxis1s;
float4		DefaultInTextureIds;

uint		BillboarderType;
uint		OutputMask;
uint		InputMask;
uint		InIndicesOffset;
uint		InputOffset;
uint		OutputVertexOffset;
uint		OutputIndexOffset;

float4x4	BillboardingMatrix;

float2		RendererAspectRatio;
float		RendererAxisScale;
uint		RendererFlags;
float		RendererNormalsBendingFactor;

uint					HasLiveParticleCount;
ByteAddressBuffer		LiveParticleCount;

uint					RendererAtlasRectCount;
ByteAddressBuffer		RendererAtlasBuffer;
//Buffer<uint>			RendererAtlasBuffer;

// RightHanded:
//#define		myCross(a, b)		cross(a, b)
// LeftHanded:
#define		myCross(a, b)		cross(b, a)

#define		swapf(x, y)		x = asfloat(asuint(x) ^ asuint(y)); y = asfloat(asuint(y) ^ asuint(x)); x = asfloat(asuint(x) ^ asuint(y));
#define		swapi(x, y)		x = x ^ y; y = y ^ x; x = x ^ y;

#define		FLOAT2_TO_USHORTUNORM2(__x, __y)	(asuint(clamp((int)(__x * 65535.0), 0, 0xFFFF)) | (asuint(clamp((int)(__y * 65535.0), 0, 0xFFFF)) << 16))
uint		Float2ToUshortUnorm2(float2 tc) { return FLOAT2_TO_USHORTUNORM2(tc.x, tc.y); }

[numthreads(PK_GPU_THREADGROUP_SIZE, 1, 1)]
void		GogoBillobardCS(uint3 DTid : SV_DispatchThreadID)
{
	const uint		globali = DTid.x;
	const uint		inputi = InputOffset + globali;

	const float3	center = asfloat(InPositions.Load3(inputi * 12));

	float2			radius;
	if (InputMask & MASK_InSizes)
		radius = (float2)asfloat(InSizes.Load(inputi * 4));
	else if (InputMask & MASK_In2Sizes)
		radius = asfloat(In2Sizes.Load2(inputi * 8));
	else
		radius = (float2)DefaultInSizes.x;

	float3			xAxis;
	float3			yAxis;
	float3			capsuleUpVec = float3(0, 0, 1);

	switch (BillboarderType)
	{
	case BILLBOARD_ScreenAlignedQuad:
	{
		radius *= RendererAspectRatio;
		xAxis = BillboardingMatrix[0].xyz * radius.x;
		yAxis = BillboardingMatrix[1].xyz * radius.y;
	}
	break;
	case BILLBOARD_ViewposAlignedQuad:
	{
		const float3	viewPos = BillboardingMatrix[3].xyz;
		const float3	camToParticle = normalize(center - viewPos);
		// Z Up:
		const float3	upAxis = float3(0, camToParticle.z * 0.01f, 1);
		// Y Up:
		//float4		upAxis = float3(0, 1, camToParticle.y * 0.01);
		radius *= RendererAspectRatio;
		xAxis = normalize(myCross(camToParticle, upAxis));
		yAxis = myCross(xAxis, camToParticle) * radius.y;
		xAxis *= radius.x;
	}
	break;
	case BILLBOARD_VelocityAxisAligned:
	{
		const float3	viewPos = BillboardingMatrix[3].xyz;
		const float3	camToParticle = center - viewPos;
		const float3	axis = asfloat(InAxis0s.Load3(inputi * 12));
		xAxis = normalize(myCross(camToParticle, axis)) * radius.x;
		yAxis = axis * 0.5f * RendererAxisScale;
	}
	break;
	case BILLBOARD_VelocityCapsuleAlign:
	{
		const float3	viewPos = BillboardingMatrix[3].xyz;
		const float3	camToParticle = normalize(center - viewPos);
		const float3	axis = asfloat(InAxis0s.Load3(inputi * 12));
		const float3	sideVec = normalize(myCross(camToParticle, axis)) * radius.x;
		const float3	upVec = myCross(sideVec, camToParticle);
		xAxis = sideVec;
		yAxis = axis * 0.5f * RendererAxisScale;
		capsuleUpVec = upVec;
	}
	break;
	case BILLBOARD_VelocitySpheroidalAlign:
	{
		const float3	viewPos = BillboardingMatrix[3].xyz;
		const float3	camToParticle = normalize(center - viewPos);
		const float3	axis = asfloat(InAxis0s.Load3(inputi * 12));
		const float3	sideVec = normalize(myCross(camToParticle, axis)) * radius.x;
		const float3	upVec = myCross(sideVec, camToParticle);
		xAxis = sideVec;
		yAxis = axis * 0.5f * RendererAxisScale + upVec;
	}
	break;
	case BILLBOARD_PlanarAlignedQuad:
	{
		const float3	axis_fwd = asfloat(InAxis0s.Load3(inputi * 12));
		const float3	axis_nrm = asfloat(InAxis1s.Load3(inputi * 12));
		xAxis = normalize(myCross(axis_fwd, axis_nrm));
		yAxis = myCross(axis_nrm, xAxis);
		const float2	scale = radius * float2(RendererAxisScale * 0.5f, 0.5f);
		xAxis *= scale.x;
		yAxis *= scale.y;
	}
	break;
	}

	if (InputMask & MASK_InRotations)
	{
		const float		a = asfloat(InRotations.Load(inputi * 4));
		const float		c = cos(a);
		const float		s = sin(a);
		const float3	xa = xAxis;
		xAxis = yAxis * s + xAxis * c;
		yAxis = yAxis * c - xa * s;
	}

	if (HasLiveParticleCount != 0)
	{
		const uint		particleCount = asint(LiveParticleCount.Load(0));
		if (inputi >= particleCount)
		{
			xAxis = float3(0, 0, 0);
			yAxis = float3(0, 0, 0);
			capsuleUpVec = float3(0, 0, 0);
		}
	}

	const float3	xpy = xAxis + yAxis;
	const float3	xmy = xAxis - yAxis;
	const float3	v0 = center - xpy;
	const float3	v1 = center + xmy;
	const float3	v2 = center + xpy;
	const float3	v3 = center - xmy;

	const uint		vpp = ((BillboarderType == BILLBOARD_VelocityCapsuleAlign) ? 6 : 4);
	const bool		is6vert = (vpp == 6);
	const uint		vstart = globali * vpp + OutputVertexOffset;


	// NOTE: Performance might benefit quite a bit from outputting packed float3 vertices
	if (OutputMask & MASK_OutPositions)
	{
#if PK_BILLBOARDER_CS_OUTPUT_PACK_PTN
		const uint	addr = vstart * 12;
		OutPositions.Store3(addr + 0 * 12, asint(v0));
		OutPositions.Store3(addr + 1 * 12, asint(v1));
		OutPositions.Store3(addr + 2 * 12, asint(v2));
		OutPositions.Store3(addr + 3 * 12, asint(v3));
		if (is6vert)
		{
			const float3		v4 = center + yAxis + capsuleUpVec;
			const float3		v5 = center - yAxis - capsuleUpVec;
			OutPositions.Store3(addr + 4 * 12, asint(v4));
			OutPositions.Store3(addr + 5 * 12, asint(v5));
		}
#else
		const uint		addr = vstart * 16;
		OutPositions.Store4(addr + 0 * 16, asint(float4(v0, 0)));
		OutPositions.Store4(addr + 1 * 16, asint(float4(v1, 0)));
		OutPositions.Store4(addr + 2 * 16, asint(float4(v2, 0)));
		OutPositions.Store4(addr + 3 * 16, asint(float4(v3, 0)));
		if (is6vert)
		{
			const float3		v4 = center + yAxis + capsuleUpVec;
			const float3		v5 = center - yAxis - capsuleUpVec;
			OutPositions.Store4(addr + 4 * 16, asint(float4(v4, 0)));
			OutPositions.Store4(addr + 5 * 16, asint(float4(v5, 0)));
		}
#endif
	}

	// @TODO early out
	//if ((OutputMask & (
	//
	//)) == 0)
	//	return

	if (OutputMask & MASK_OutNormals)
	{
		float3			normal0;
		float3			normal1;
		float3			normal2;
		float3			normal3;

		float3			xAxisNorm;
		float3			yAxisNorm;
		if (RendererNormalsBendingFactor > 0)
		{
			xAxisNorm = normalize(xAxis);
			yAxisNorm = normalize(yAxis);

			const float3	baseNormal = myCross(xAxisNorm, yAxisNorm); // already ortho
			const float3	nw = baseNormal * (1.0f - RendererNormalsBendingFactor);

			const float3	xpy = (xAxisNorm + yAxisNorm) * RendererNormalsBendingFactor;
			const float3	xmy = (xAxisNorm - yAxisNorm) * RendererNormalsBendingFactor;
			normal0 = nw - xpy;
			const float3	rlen = 1.0f / length(normal0);
			normal0 *= rlen;
			normal1 = (nw + xmy) * rlen;
			normal2 = (nw + xpy) * rlen;
			normal3 = (nw - xmy) * rlen;
		}
		else
		{
			const float3	baseNormal = normalize(myCross(xAxis, yAxis));
			normal0 = baseNormal;
			normal1 = baseNormal;
			normal2 = baseNormal;
			normal3 = baseNormal;
		}

#if PK_BILLBOARDER_CS_OUTPUT_PACK_PTN
		// normals
		{
			const uint		addr = vstart * 12;
			OutNormals.Store3(addr + 0 * 12, asint(normal0));
			OutNormals.Store3(addr + 1 * 12, asint(normal1));
			OutNormals.Store3(addr + 2 * 12, asint(normal2));
			OutNormals.Store3(addr + 3 * 12, asint(normal3));
			if (is6vert)
			{
				const float3		normal4 = normal2; // @TODO fixme ?
				const float3		normal5 = normal0;
				OutNormals.Store3(addr + 4 * 12, asint(normal4));
				OutNormals.Store3(addr + 5 * 12, asint(normal5));
			}
		}
		// no tangent without normals anyway
		if (OutputMask & MASK_OutTangents)
		{
			const uint		addr = vstart * 12;
			//const float3	tangent = RendererNormalsBendingFactor > 0 ? xAxisNorm : normalize(xAxis);
			const float3	tangent = normalize(xAxis);

			OutTangents.Store3(addr + 0 * 12, asint(tangent));
			OutTangents.Store3(addr + 1 * 12, asint(tangent));
			OutTangents.Store3(addr + 2 * 12, asint(tangent));
			OutTangents.Store3(addr + 3 * 12, asint(tangent));
			if (is6vert)
			{
				OutTangents.Store3(addr + 4 * 12, asint(tangent));
				OutTangents.Store3(addr + 5 * 12, asint(tangent));
			}
		}
#else
		// normals
		{
			const uint		addr = vstart * 16;
			OutNormals.Store4(addr + 0 * 16, asint(float4(normal0, 0)));
			OutNormals.Store4(addr + 1 * 16, asint(float4(normal1, 0)));
			OutNormals.Store4(addr + 2 * 16, asint(float4(normal2, 0)));
			OutNormals.Store4(addr + 3 * 16, asint(float4(normal3, 0)));
			if (is6vert)
			{
				const float3		normal4 = normal2; // @TODO fixme ?
				const float3		normal5 = normal0;
				OutNormals.Store4(addr + 4 * 16, asint(float4(normal4, 0)));
				OutNormals.Store4(addr + 5 * 16, asint(float4(normal5, 0)));
			}
		}
		// no tangent without normals anyway
		if (OutputMask & MASK_OutTangents)
		{
			const uint		addr = vstart * 16;
			//const float3	tangent = RendererNormalsBendingFactor > 0 ? xAxisNorm : normalize(xAxis);
			const float3	tangent = normalize(xAxis);

			OutTangents.Store4(addr + 0 * 16, asint(float4(tangent, 0)));
			OutTangents.Store4(addr + 1 * 16, asint(float4(tangent, 0)));
			OutTangents.Store4(addr + 2 * 16, asint(float4(tangent, 0)));
			OutTangents.Store4(addr + 3 * 16, asint(float4(tangent, 0)));
			if (is6vert)
			{
				OutTangents.Store4(addr + 4 * 16, asint(float4(tangent, 0)));
				OutTangents.Store4(addr + 5 * 16, asint(float4(tangent, 0)));
			}
		}
#endif
	}

	if (OutputMask & MASK_OutColors)
	{
		float4			color;
		if (InputMask & MASK_InColors)
			color = asfloat(InColors.Load4(globali * 16));
		else
			color = DefaultInColors;
		//color = float4(10, 0.1, 0.1, 1);

#if PK_BILLBOARDER_CS_OUTPUT_PACK_COLOR_F16
		const uint		addr = vstart * 8;
		uint4			colori4 = f32tof16(color);
		uint2			colorPacked = uint2(
			colori4.x | (colori4.y << 16),
			colori4.z | (colori4.w << 16)
		);
		OutColors.Store2(addr + 0 * 8, asint(colorPacked));
		OutColors.Store2(addr + 1 * 8, asint(colorPacked));
		OutColors.Store2(addr + 2 * 8, asint(colorPacked));
		OutColors.Store2(addr + 3 * 8, asint(colorPacked));
		if (is6vert)
		{
			OutColors.Store2(addr + 4 * 8, asint(colorPacked));
			OutColors.Store2(addr + 5 * 8, asint(colorPacked));
		}
#else
		const uint		addr = vstart * 16;
		OutColors.Store4(addr + 0 * 16, asint(color));
		OutColors.Store4(addr + 1 * 16, asint(color));
		OutColors.Store4(addr + 2 * 16, asint(color));
		OutColors.Store4(addr + 3 * 16, asint(color));
		if (is6vert)
		{
			OutColors.Store4(addr + 4 * 16, asint(color));
			OutColors.Store4(addr + 5 * 16, asint(color));
		}
#endif
	}

	if (OutputMask & MASK_OutTexcoords)
	{
#if PK_BILLBOARDER_CS_OUTPUT_PACK_TEXCOORD
#	define tc_t				uint
#	define tc_Store			Store
#	define tc_Stride		4
#	define tc_swap(a, b)	swapi(a, b)
#	define TC_PACK(a, b)	FLOAT2_TO_USHORTUNORM2(a, b)
#	define tc_pack(a)		Float2ToUshortUnorm2(a)
#else
#	define tc_t				float2
#	define tc_Store			Store2
#	define tc_Stride		8
#	define tc_swap(a, b)	swapf(a, b)
#	define TC_PACK(a, b)	float2(a, b)
#	define tc_pack(a)		a
#endif
		tc_t	uv00;
		tc_t	uv01;
		tc_t	uv11;
		tc_t	uv10;
		tc_t	uv00_2;
		tc_t	uv01_2;
		tc_t	uv11_2;
		tc_t	uv10_2;
		float	softAnimBlend = 0;

		if (InputMask & MASK_InTextureIds)
		{
			const float		atlasIdf = asfloat(InTextureIds.Load(inputi * 4));
			const uint		atlasId0 = min((uint)abs(atlasIdf), RendererAtlasRectCount - 1);

			const float4	rect0 = asfloat(RendererAtlasBuffer.Load4(atlasId0 * 4 * 4));
			//const float4	rect0 = asfloat(RendererAtlasBuffer[atlasId0 * 4]);

			uv00 = tc_pack(float2(0, 0) * rect0.xy + rect0.zw);
			uv01 = tc_pack(float2(0, 1) * rect0.xy + rect0.zw);
			uv10 = tc_pack(float2(1, 0) * rect0.xy + rect0.zw);
			uv11 = tc_pack(float2(1, 1) * rect0.xy + rect0.zw);

			if (RendererFlags & RENDERERFLAG_SoftAnimationBlending) // should be true too: (OutputMask & MASK_OutTexcoord2s)
			{
				const uint		atlasId1 = min(atlasId0 + 1, RendererAtlasRectCount - 1);
				const float4	rect1 = asfloat(RendererAtlasBuffer.Load4(atlasId1 * 4 * 4));
				//const float4	rect1 = asfloat(RendererAtlasBuffer[atlasId1 * 4]);

				uv00_2 = tc_pack(float2(0, 0) * rect1.xy + rect1.zw);
				uv01_2 = tc_pack(float2(0, 1) * rect1.xy + rect1.zw);
				uv10_2 = tc_pack(float2(1, 0) * rect1.xy + rect1.zw);
				uv11_2 = tc_pack(float2(1, 1) * rect1.xy + rect1.zw);

				// MASK_OutAtlasIDs should be active too
				softAnimBlend = frac(atlasIdf);
			}
		}
		else
		{
			uv00 = TC_PACK(0, 0);
			uv01 = TC_PACK(0, 1);
			uv11 = TC_PACK(1, 1);
			uv10 = TC_PACK(1, 0);
			uv00_2 = TC_PACK(0, 0);
			uv01_2 = TC_PACK(0, 1);
			uv11_2 = TC_PACK(1, 1);
			uv10_2 = TC_PACK(1, 0);
		}

		if (RendererFlags & RENDERERFLAG_FlipV)
		{
			tc_swap(uv01, uv00);
			tc_swap(uv11, uv10);
			tc_swap(uv01_2, uv00_2);
			tc_swap(uv11_2, uv10_2);
		}

		// Texcoord
		{
			const uint		addr = vstart * tc_Stride;
			if (!is6vert)
			{
				OutTexcoords.tc_Store(addr + 0 * tc_Stride, asint(uv01));
				OutTexcoords.tc_Store(addr + 1 * tc_Stride, asint(uv11));
				OutTexcoords.tc_Store(addr + 2 * tc_Stride, asint(uv10));
				OutTexcoords.tc_Store(addr + 3 * tc_Stride, asint(uv00));
			}
			else
			{
				OutTexcoords.tc_Store(addr + 0 * tc_Stride, asint(uv00));
				OutTexcoords.tc_Store(addr + 1 * tc_Stride, asint(uv11));
				OutTexcoords.tc_Store(addr + 2 * tc_Stride, asint(uv11));
				OutTexcoords.tc_Store(addr + 3 * tc_Stride, asint(uv00));
				OutTexcoords.tc_Store(addr + 4 * tc_Stride, asint(uv01));
				OutTexcoords.tc_Store(addr + 5 * tc_Stride, asint(uv10));
			}
		}

		if (OutputMask & MASK_OutTexcoord2s)
		{
			const uint		addr = vstart * tc_Stride;
			if (!is6vert)
			{
				OutTexcoord2s.tc_Store(addr + 0 * tc_Stride, asint(uv01_2));
				OutTexcoord2s.tc_Store(addr + 1 * tc_Stride, asint(uv11_2));
				OutTexcoord2s.tc_Store(addr + 2 * tc_Stride, asint(uv10_2));
				OutTexcoord2s.tc_Store(addr + 3 * tc_Stride, asint(uv00_2));
			}
			else
			{
				const uint		addr = vstart * tc_Stride;
				OutTexcoord2s.tc_Store(addr + 0 * tc_Stride, asint(uv00_2));
				OutTexcoord2s.tc_Store(addr + 1 * tc_Stride, asint(uv11_2));
				OutTexcoord2s.tc_Store(addr + 2 * tc_Stride, asint(uv11_2));
				OutTexcoord2s.tc_Store(addr + 3 * tc_Stride, asint(uv00_2));
				OutTexcoord2s.tc_Store(addr + 4 * tc_Stride, asint(uv01_2));
				OutTexcoord2s.tc_Store(addr + 5 * tc_Stride, asint(uv10_2));
			}
		}

		if (OutputMask & MASK_OutAtlasIDs)
		{
			//// 0-4
			//OutAtlasIDs.Store4(vstart * 4 + 0 * 4, asint((float4)softAnimBlend));
			//if (!is6vert)
			//{
			//	// 4-6
			//	OutAtlasIDs.Store2(vstart * 4 + 4 * 4, asint((float2)softAnimBlend));
			//}
			//else
			//{
			//	// 4-8
			//	OutAtlasIDs.Store4(vstart * 4 + 4 * 4, asint((float4)softAnimBlend));
			//	// 8-12
			//	OutAtlasIDs.Store4(vstart * 4 + 8 * 4, asint((float4)softAnimBlend));
			//}

			const uint		dynStride = 4;
			OutAtlasIDs.Store(vstart * dynStride + 0 * dynStride, asint(softAnimBlend));
			OutAtlasIDs.Store(vstart * dynStride + 1 * dynStride, asint(softAnimBlend));
			OutAtlasIDs.Store(vstart * dynStride + 2 * dynStride, asint(softAnimBlend));
			OutAtlasIDs.Store(vstart * dynStride + 3 * dynStride, asint(softAnimBlend));
			if (is6vert)
			{
				OutAtlasIDs.Store(vstart * dynStride + 4 * dynStride, asint(softAnimBlend));
				OutAtlasIDs.Store(vstart * dynStride + 5 * dynStride, asint(softAnimBlend));
			}
		}
	}

	if (OutputMask & MASK_OutIndices)
	{
		const uint		istart = OutputIndexOffset + globali * (is6vert ? 12 : 6);
		uint			vertexi;
		if (InputMask & MASK_InIndices)
		{
			vertexi = InIndices.Load((InIndicesOffset + globali) * 4);
		}
		else
		{
			vertexi = vstart;
		}

#if 1
		OutIndices[istart + 0] = vertexi + 0;
		OutIndices[istart + 1] = vertexi + 1;
		OutIndices[istart + 2] = vertexi + 3;
		OutIndices[istart + 3] = vertexi + 1;
		OutIndices[istart + 4] = vertexi + 2;
		OutIndices[istart + 5] = vertexi + 3;
		if (is6vert)
		{
			OutIndices[istart + 6  ] = vertexi + 4;
			OutIndices[istart + 7  ] = vertexi + 3;
			OutIndices[istart + 8  ] = vertexi + 2;
			OutIndices[istart + 9  ] = vertexi + 1;
			OutIndices[istart + 10 ] = vertexi + 0;
			OutIndices[istart + 11 ] = vertexi + 5;
		}
#else
		OutIndices.Store(istart * 4 + 0 * 4, vertexi + 0);
		OutIndices.Store(istart * 4 + 1 * 4, vertexi + 1);
		OutIndices.Store(istart * 4 + 2 * 4, vertexi + 3);
		OutIndices.Store(istart * 4 + 3 * 4, vertexi + 1);
		OutIndices.Store(istart * 4 + 4 * 4, vertexi + 2);
		OutIndices.Store(istart * 4 + 5 * 4, vertexi + 3);
		if (is6vert)
		{
			OutIndices.Store(istart * 4 + 6 * 4, vertexi + 4);
			OutIndices.Store(istart * 4 + 7 * 4, vertexi + 3);
			OutIndices.Store(istart * 4 + 8 * 4, vertexi + 2);
			OutIndices.Store(istart * 4 + 9 * 4, vertexi + 1);
			OutIndices.Store(istart * 4 + 10 * 4, vertexi + 0);
			OutIndices.Store(istart * 4 + 11 * 4, vertexi + 5);
		}
#endif

	}
}
